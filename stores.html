<!DOCTYPE html>
<html>
<head>
    <title>Shop Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-contextmenu/1.4.0/leaflet.contextmenu.min.css" />
    <style>
        html, body { height: 100%; margin: 0; padding: 0; }
        #container { display: flex; height: 100vh; }
        #map { flex: 3; height: 100%; min-height: 500px; }
        #store-list { flex: 1; overflow-y: auto; padding: 10px; }
        .store-item { cursor: pointer; padding: 5px; }
        .store-item:hover { background-color: #f0f0f0; }
        #debug-info { display: flex; max-height: 150px; border: 1px solid #ccc; background-color: #f9f9f9; }
        #debug-container { flex: 1; overflow-y: auto; padding: 5px; border-right: 1px solid #ccc; }
        #postal-code-container { flex: 1; overflow-y: auto; padding: 5px; }
        #postal-code-list li.selected { background-color: lightblue; }
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 10000;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
        }
        .loader {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.5s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<div id="js-status" style="padding: 10px; background-color: lightyellow; border: 1px solid orange;"></div>


<div id="loading-overlay">
    <div class="loader"></div>
</div>

<div id="debug-info">
    <div id="debug-container">
        <h3>Debug Information</h3>
        <div id="tsp-progress" style="color: red;"></div>
        <pre id="debug-output" style="white-space: pre-wrap;"></pre>
        <h3>Cached Postal Data (Sample)</h3>
        <pre id="postal-data-sample" style="white-space: pre-wrap;"></pre>
    </div>
    <div id="postal-code-container">
        <h3>Unique Postal Codes on Map</h3>
        <div id="start-store-selector-container" style="display: none; margin-bottom: 10px;">
            <label for="startStoreSelector">Select Starting Store:</label>
            <select id="startStoreSelector"></select>
        </div>
        <ul id="postal-code-list"></ul>
        <div id="tsp-distance-container" style="margin-top: 10px;"></div>
    </div>
</div>

<div id="recent-clicks" style="border: 1px solid black; padding: 10px; margin-bottom: 10px;">
    <h3>Recently Clicked Stores</h3>
    <div id="clicked-store-1"></div>
    <div id="clicked-store-2"></div>
    <div id="distance-between-markers"></div>
</div>

<div style="margin-bottom: 10px;">
    <label for="postalCodeFilter">Filter by Postal Code:</label>
    <input type="text" id="postalCodeFilter" placeholder="Enter postal code">
    <button id="applyFilter">Apply Filter</button>
    <button id="clearFilter">Clear Filter</button>
    <button id="useCurrentLocation">Use Current Location</button>
    <button id="clearPostalCache">Clear Postal Cache</button>
    <button id="generateKml" disabled>Generate KML</button>
</div>
<div id="marker-count" style="margin-bottom: 10px;"></div>
<div id="container">
    <div id="map"></div>
    <div id="store-list"></div>
</div>



<script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"></script>
    
    <script>
        // This MUST be defined before other scripts try to use it.
        function logDebug(message) {
            const debugOutput = document.getElementById('debug-output');
            console.log(message); // Also log to browser console
            if (debugOutput) {
                debugOutput.textContent += message + '\n';
            } else {
                // Fallback if the debug element isn't ready yet
                console.log('Debug element not found, logging to console only:', message);
            }
        }
    </script>
    <script src="https://unpkg.com/topojson@3.0.2/dist/topojson.min.js"></script>
    <script>logDebug('Topojson.js loaded.');</script>
    <script src="https://unpkg.com/leaflet-topojson@0.3.0/dist/leaflet-topojson.min.js"></script>
    <script>logDebug('Leaflet-Topojson.js loaded.');</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-contextmenu/1.4.0/leaflet.contextmenu.min.js"></script>
    
    <script>
        logDebug('Leaflet-Contextmenu.js loaded.');
    </script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
    // IndexedDB helper functions
    const dbName = 'PostalDataDB';
    const postalStoreName = 'postalCodes';
    const kvStoreName = 'keyValueStore';

    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(dbName, 2); // Version bumped to 2
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                logDebug('Upgrading IndexedDB...');
                if (!db.objectStoreNames.contains(postalStoreName)) {
                    db.createObjectStore(postalStoreName, { keyPath: 'postalCode' });
                    logDebug(`Object store '${postalStoreName}' created.`);
                }
                if (!db.objectStoreNames.contains(kvStoreName)) {
                    db.createObjectStore(kvStoreName, { keyPath: 'key' });
                    logDebug(`Object store '${kvStoreName}' created.`);
                }
            };
            request.onsuccess = (event) => {
                resolve(event.target.result);
            };
            request.onerror = (event) => {
                reject('IndexedDB error: ' + event.target.errorCode);
            };
        });
    }

    async function setItemToDB(key, value) {
        const db = await openDB();
        const transaction = db.transaction(kvStoreName, 'readwrite');
        const store = transaction.objectStore(kvStoreName);
        store.put({ key, value });
        return transaction.complete;
    }

    async function getItemFromDB(key) {
        const db = await openDB();
        const transaction = db.transaction(kvStoreName, 'readonly');
        const store = transaction.objectStore(kvStoreName);
        const record = await new Promise((resolve, reject) => {
            const request = store.get(key);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        return record ? record.value : null;
    }

    async function removeItemFromDB(key) {
        const db = await openDB();
        const transaction = db.transaction(kvStoreName, 'readwrite');
        const store = transaction.objectStore(kvStoreName);
        store.delete(key);
        return transaction.complete;
    }
    
    async function clearItemsFromDBWithPrefix(prefix) {
        const db = await openDB();
        const transaction = db.transaction(kvStoreName, 'readwrite');
        const store = transaction.objectStore(kvStoreName);
        const request = store.openCursor();
        await new Promise((resolve, reject) => {
            transaction.oncomplete = () => {
                logDebug(`Cleared items with prefix '${prefix}' from '${kvStoreName}'.`);
                resolve();
            };
            transaction.onerror = (event) => {
                reject(event.target.error);
            };
            request.onsuccess = event => {
                const cursor = event.target.result;
                if (cursor) {
                    if (String(cursor.key).startsWith(prefix)) {
                        cursor.delete();
                    }
                    cursor.continue();
                }
            };
        });
    }

    async function saveDataToDB(data) {
        const db = await openDB();
        const transaction = db.transaction(postalStoreName, 'readwrite');
        const store = transaction.objectStore(postalStoreName);
        Object.keys(data).forEach(postalCode => {
            store.put({ postalCode, data: data[postalCode] });
        });
        return transaction.complete;
    }

    let postalCodeAddressCache = null;

    async function getDataFromDB() {
        if (postalCodeAddressCache) {
            logDebug('Using in-memory postal code address cache.');
            return postalCodeAddressCache;
        }
        const db = await openDB();
        const transaction = db.transaction(postalStoreName, 'readonly');
        const store = transaction.objectStore(postalStoreName);
        const allRecords = await new Promise((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });

        const postalData = {};
        allRecords.forEach(record => {
            postalData[record.postalCode] = record.data;
        });
        postalCodeAddressCache = postalData;
        return postalData;
    }

    // Function to fetch, unzip, and cache the postal code data
    async function fetchAndCachePostalData() {
        const cacheTimestampKey = 'postal_data_ken_all_rome_timestamp';
        const cacheDuration = 24 * 60 * 60 * 1000; // 24 hours

        const cachedTimestamp = await getItemFromDB(cacheTimestampKey);

        if (cachedTimestamp && (new Date().getTime() - cachedTimestamp < cacheDuration)) {
            logDebug('Using cached postal data from IndexedDB.');
            return await getDataFromDB();
        }

        try {
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZip library is not loaded. Cannot unzip the file.');
            }
            logDebug('Fetching postal data zip file...');
            showLoading();
            // substring of window.location.href up to the last '/'
	    const lastSlashIndex = window.location.href.lastIndexOf('/');
	    if (lastSlashIndex === -1) {
	throw new Error('Invalid URL: No slash found in the URL.');
	}
	const baseUrl = window.location.href.substring(0, lastSlashIndex + 1);
	       const response = await fetch(baseUrl + 'zipcode/dl/roman/KEN_ALL_ROME.zip');
            if (!response.ok) {
                throw new Error(`Failed to fetch zip file: ${response.statusText}`);
            }
            const zipBlob = await response.blob();
            logDebug('Zip file fetched. Unzipping...');

            const jszip = new JSZip();
            const zip = await jszip.loadAsync(zipBlob);
            const csvFileName = Object.keys(zip.files)[0];
            if (!csvFileName) {
                throw new Error('No file found in the zip archive.');
            }

            logDebug(`Unzipping file: ${csvFileName}`);
            const csvContentUint8Array = await zip.files[csvFileName].async('uint8array');
            const decoder = new TextDecoder('shift-jis');
            const csvContent = decoder.decode(csvContentUint8Array);
            logDebug('CSV content extracted. Parsing...');

            // Simple CSV parser
            const lines = csvContent.split('\n');
            const postalData = {};
            for (const line of lines) {
                const parts = line.split(',').map(item => item.trim().replace(/"/g, ''));
                if (parts.length >= 3) {
                    const postalCode = parts[0];
                    const prefecture = parts[1];
                    const city = parts[2];
                    const address = parts[3] || '';
                    if (!postalData[postalCode]) {
                        postalData[postalCode] = [];
                    }
                    postalData[postalCode].push({ prefecture, city, address });
                }
            }

            logDebug('Parsing complete. Caching data to IndexedDB...');
            await saveDataToDB(postalData);
            await setItemToDB(cacheTimestampKey, new Date().getTime());
            logDebug('Postal data cached successfully in IndexedDB.');
            return postalData; // Return newly fetched data
        } catch (error) {
            logDebug(`Error fetching or processing postal data: ${error}`);
            console.error('Error fetching or processing postal data:', error);
            return null; // Return null on error
        } finally {
            hideLoading();
        }
    }

    // Function to get postal data from cache
    async function getPostalData(postalCode) {
        const postalData = await getDataFromDB();
        return postalData[postalCode] || null;
    }

    // Function to display a sample of the cached postal data
    function displayCachedDataSample(postalData) {
        const sampleContainer = document.getElementById('postal-data-sample');
        if (!sampleContainer) return;

        if (postalData && Object.keys(postalData).length > 0) {
            // Take the first 10 items from the cached data to display as a sample.
            const first10Entries = Object.entries(postalData).slice(0, 10);
            const logMessage = 'logDebug: Displayed sample of cached postal data.';
            sampleContainer.textContent = logMessage + '\n\n' + JSON.stringify(first10Entries, null, 2);
            logDebug('Displayed sample of cached postal data.'); // Also log to the main debug area
        } else if (postalData) {
            const logMessage = 'logDebug: Cached postal data was found but is empty.';
            sampleContainer.textContent = logMessage;
            logDebug('Cached postal data was found but is empty.');
        } else {
            const logMessage = 'logDebug: No cached data found or failed to fetch.';
            sampleContainer.textContent = logMessage;
            logDebug('No postal data available to display as sample.');
        }
    }
</script>

<script>

    const loadingOverlay = document.getElementById('loading-overlay');

    function showLoading() {
        if (loadingOverlay) loadingOverlay.style.display = 'flex';
    }

    function hideLoading() {
        if (loadingOverlay) loadingOverlay.style.display = 'none';
    }
document.addEventListener('DOMContentLoaded', function() {
    logDebug('DOM fully loaded and parsed.');
    fetchAndCachePostalData().then(postalData => {
        displayCachedDataSample(postalData);
    });


    var map;
    var markers;
    var routeLine;

    var allStores = new Map(); // Use a Map to store stores by ID, preventing duplicates
    
    var recentlyClickedStores = []; // To store recently clicked store names
    var clickedStore1Div = document.getElementById('clicked-store-1');
    var clickedStore2Div = document.getElementById('clicked-store-2');
    var distanceBetweenMarkersDiv = document.getElementById('distance-between-markers');
    var storeList = document.getElementById('store-list');
    var postalCodeFilterInput = document.getElementById('postalCodeFilter');
    var applyFilterButton = document.getElementById('applyFilter');
    var clearFilterButton = document.getElementById('clearFilter');
    var useCurrentLocationButton = document.getElementById('useCurrentLocation');
    var markerCountDiv = document.getElementById('marker-count');
    var apiUrl = 'http://localhost:8080/mmeu/api/v3/stores?client_id=integrated&longitude=139.641021&latitude=35.909794'; // Default API URL

    


    // List of strings to filter out from store names
    const EXCLUDE_STORE_NAMES_CONTAINING = [
	"NPC24H", "NPC24H",
	"ホワイト急便", "ﾎﾜｲﾄ急便",
	"木曽路", "木曽路",
	"和食処とんでん", "和食処とんでん",
	"すき家", "ｽｷﾔ",
	"松屋", "ﾏﾂﾔ",
	"吉野家", "ﾖｼﾉﾔ",
	"いちげん", "いちげん",
	"BOOKOFF", "BOOKOFF",
	"ニッポンレンタカー", "ﾆｯﾎﾟﾝﾚﾝﾀｶｰ",
	"スギドラッグ", "ｽｷﾞﾄﾞﾗｯｸﾞ",
	"ビーンズ", "ﾋﾞｰﾝｽﾞ",
	"AOKI", "AOKI",
	"ユニクロ", "ﾕﾆｸﾛ",
	"GU", "GU",
	"無印良品", "ﾑｼﾞﾙｼﾘｮｳﾋﾝ",
	"ニトリ", "ﾆﾄﾘ",
	"ケーズデンキ", "ｹｰｽﾞﾃﾞﾝｷ",
	"ヤマダ電機", "ﾔﾏﾀﾞﾃﾞﾝｷ",
	"ビックカメラ", "ﾋﾞｯｸｶﾒﾗ",
	"ヨドバシカメラ", "ﾖﾄﾞ\u0008ﾞｼｶﾒﾗ",
	"エディオン", "エディオン",
	"ジョーシン", "ｼﾞｮｰｼﾝ",
	"コジマ", "ｺｼﾞﾏ",
	"ソフマップ", "ｿﾌﾏｯﾌﾟ",
	"ノジマ", "ﾉｼﾞﾏ",
	"ウエルシア", "ｳｪﾙｼｱ",
	"郵便局 ", "郵便局",
	"ヤマト運輸", "ﾔﾏﾄ運輸",
	"佐川急便", "ｻｶﾞﾜ急便",
	"ホームセンターコーナン", "ﾎｰﾑｾﾝﾀｰｺｰﾅﾝ",
	"ＨｏｎｄａＣａｒｓ", "Honda Cars",
	"ドラッグセイムス", "ﾄﾞﾗｯｸﾞｾｲﾑｽ",
	"ＮｅｗＤａｙｓ", "NewDays",
	"ドラッグストアセキ", "ﾄﾞﾗｯｸﾞｽﾄｱｾｷ",
	"ベルクス", "ﾍﾞﾙｸｽ",
	"富士薬局", "富士薬局",
	"やまや", "やまや",
	"ヨークマート", "ﾖｰｸﾏｰﾄ",
	"東横イン", "東横イン",
	"幸楽苑", "幸楽苑",
	"安楽亭", "安楽亭",
	"ドミノピザ", "ﾄﾞﾐﾉﾋﾟｻﾞ",
	"タイムズ", "ﾀｲﾑｽﾞ",
	"ビッグエコー", "ﾋﾞｯｸﾞｴｺｰ",
	"餃子の王将", "餃子の王将",
	"ジョリーパスタ", "ｼﾞｮﾘｰﾊﾟｽﾀ",
	"大戸屋ごはん処", "大戸屋ごはん処",
	"日高屋", "日高屋",
	"スシロー", "ｽｼﾛｰ",
	"くら寿司", "くら寿司",
	"はま寿司", "はま寿司",
	"かっぱ寿司", "かっぱ寿司",
	"マクドナルド", "ﾏｸﾄﾞﾅﾙﾄﾞ",
	"ケンタッキーフライドチキン", "ｹﾝﾀｯｷｰﾌﾗｲﾄﾞﾁｷﾝ",
	"出光", "出光",
	"牛角", "牛角",
	"ガスト", "ｶﾞｽﾄ",
	"ベルク", "ﾍﾞﾙｸ",
	"丸亀製麺", "丸亀製麺",
	"ほっともっと", "ﾎｯﾄﾓｯﾄ",
	"ＥＮＥＯＳ", "ENEOS",
	"Honda Dream", "Honda Dream",
	"ロイヤルホスト", "ﾛｰﾔﾙﾎｽﾄ",
	"セキ薬局", "ｾｷﾔｯｷｮｸ",
        "閉店", // Closed
        "セブンイレブン", "ｾﾌﾞﾝｲﾚﾌﾞﾝ",
        "ファミリーマート", "ﾌｧ��ﾘｰﾏｰﾄ",
        "ローソン", "ﾛｰｿﾝ",
        "ミニストップ", "ﾐﾆｽﾄｯﾌﾟ",
        "イオン", "イオン",
        "イトーヨーカドー", "イトーヨーカドー",
        "マクドナルド", "ﾏｸﾄﾞﾅﾙﾄﾞ",
        "スターバックス", "ｽﾀｰﾊﾞｯｸｽ",
        "ドトール", "ﾄﾞﾄｰﾙ",
        "タリーズ", "ﾀﾘｰｽﾞ",
        "モスバーガー", "ﾓｽﾊﾞｰｶﾞｰ",
        "吉野家", "ﾖｼﾉﾔ",
        "すき家", "ｽｷﾔ",
        "松屋", "ﾏﾂﾔ",
        "CoCo壱番屋", "CoCo壱番屋",
	"cocos", "ココス",
        "ガスト", "ｶﾞｽﾄ",
        "サイゼリヤ", "ｻｲｾﾞﾘﾔ",
        "ドラッグエース＋調剤", "ﾄﾞﾗｯｸﾞｴｰｽ＋ﾁｮｳｻﾞｲ",
        "ユニクロ", "ﾕﾆｸﾛ",
        "GU", "GU",
        "無印良品", "ﾑｼﾞﾙｼﾘｮｳﾋﾝ",
        "ニトリ", "ﾆﾄﾘ",
        "ケーズデンキ", "ｹｰｽﾞﾃﾞﾝｷ",
        "ヤマダ電機", "ﾔﾏﾀ���ﾃﾞﾝｷ",
        "ビックカメラ", "ﾋﾞｯｸｶﾒﾗ",
        "ヨドバシカメラ", "ﾖﾄﾞ\u0008ﾞｼｶﾒﾗ",
        "エディオン", "エディオン",
        "ジョーシン", "ｼﾞｮｰｼﾝ",
        "コジマ", "ｺｼﾞﾏ",
        "ソフマップ", "ｿﾌﾏｯﾌﾟ",
        "ノジマ", "ﾉｼﾞﾏ",
        "ベスト電器", "ﾍﾞｽﾄﾃﾞﾝｷ",
        "マクドナルド", "ﾏｸﾄﾞﾅﾙﾄﾞ",
        "スターバックス", "ｽﾀｰﾊﾞｯｸｽ",
        "ドトールコーヒー", "ﾄﾞﾄｰﾙｺｰﾋｰ",
        "タリーズコーヒー", "ﾀﾘｰｽﾞｺｰﾋｰ",
        "モスバーガー", "ﾓｽﾊﾞｰｶﾞｰ",
        "ケンタッキーフライドチキン", "ｹﾝﾀｯｷｰﾌﾗｲﾄﾞﾁｷﾝ",
        "サブウェイ", "ｻﾌﾞｳｪｲ",
        "フレッシュネスバーガー", "ﾌﾚｯｼｭﾈｽﾊﾞｰｶﾞｰ",
        "ロッテリア", "ﾛｯﾃﾘｱ",
        "ファーストキッチン", "ﾌｧｰｽﾄｷｯﾁﾝ",
        "吉野家", "ﾖｼﾉﾔ",
        "すき家", "ｽｷﾔ",
        "松屋", "ﾏﾂﾔ",
        "なか卯", "ﾅｶｳ",
        "CoCo壱番屋", "ココイチバンヤ",
        "ガスト", "ｶﾞｽﾄ",
        "サイゼリヤ", "ｻｲｾﾞﾘﾔ",
        "デニーズ", "ﾃﾞﾆｰｽﾞ",
        "ジョナサン", "ｼﾞｮﾅｻﾝ",
        "バーミヤン", "ﾊﾞｰﾐﾔﾝ",
	"焼鳥日高", "ﾔｷﾄﾘﾋﾀﾞｶ",
        "夢庵", "ﾕﾒｱﾝ",
        "ステーキガスト", "ｽﾃｰｷｶﾞｽﾄ",
        "から好し", "ｶﾗﾖｼ",
        "しゃぶ葉", "ｼｬﾌﾞﾖｳ",
        "グラッチェガーデンズ", "ｸﾞﾗｯﾁｪｶﾞｰﾃﾞﾝｽﾞ",
        "藍屋", "ｱｲﾔ",
        "魚屋路", "ﾄﾄﾔﾐﾁ",
        "むさしの森珈琲", "ﾑｻｼﾉﾓﾘｺｰﾋｰ",
        "セリア", "ｾﾘｱ",
        "ダイソー", "ﾀﾞｲｿｰ",
        "キャンドゥ", "ｷｬﾝﾄﾞｩ",
        "ワッツ", "ﾜｯﾂ",
        "meets.", "meets.",
        "シルク", "ｼ���ｸ",
        "Can★Do", "Can★Do",
        "Seria", "Seria",
        "Daiso", "Daiso",
        "Watts", "Watts",
        "イオン", "イオン",
        "イトーヨーカドー", "イトーヨーカドー",
        "ライフ", "ﾗｲﾌ",
        "西友", "ｾｲﾕｳ",
        "マルエツ", "ﾏﾙｴﾂ",
        "サミット", "ｻﾐｯﾄ",
        "オーケー", "ｵｰｹｰ",
        "成城石井", "ｾｲｼﾞｮｳｲｼｲ",
        "紀ノ国屋", "ｷﾉｸﾆﾔ",
        "クイーンズ伊勢丹", "ｸｲｰﾝｽﾞｲｾﾀﾝ",
        "明治屋", "ﾒｲｼﾞﾔ",
        "ピーコックストア", "ﾋﾟｰｺｯｸｽﾄｱ",
        "東武ストア", "ﾄｳﾌﾞｽﾄｱ",
        "京王ストア", "ｹｲｵｳｽﾄｱ",
        "小田急OXストア", "ｵﾀﾞｷｭｳOXｽﾄｱ",
        "東急ストア", "ﾄｳｷｭｳｽﾄｱ",
        "Odakyu OX", "Odakyu OX",
        "Tokyu Store", "Tokyu Store",
        "Summit", "Summit",
        "Maruetsu", "Maruetsu",
        "Seiyu", "Seiyu",
        "Life", "Life",
        "Aeon", "Aeon",
        "Ito-Yokado", "Ito-Yokado",
        "OK Store", "OK Store",
        "Seijo Ishii", "Seijo Ishii",
        "Kinokuniya", "Kinokuniya",
        "Queens Isetan", "Queens Isetan",
        "Meidi-Ya", "Meidi-Ya",
        "Peacock Store", "Peacock Store",
        "Tobu Store", "Tobu Store",
        "Keio Store", "Keio Store",
        "ドン・キホーテ", "ﾄﾞﾝ･ｷﾎｰﾃ",
        "ロフト", "ﾛﾌﾄ",
        "東急ハンズ", "ﾄｳｷｭｳﾊﾝｽﾞ",
        "PLAZA", "PLAZA",
        "アインズ＆トルペ", "ｱｲﾝｽﾞｱﾝﾄﾞﾄﾙﾍﾟ",
        "ショップイン", "ｼｮｯﾌﾟｲﾝ",
        "アットコスメストア", "ｱｯﾄｺｽﾒｽﾄｱ",
        "ハンズ", "ﾊﾝｽﾞ",
        "ドンキ", "ﾄﾞﾝｷ",
        "LOFT", "LOFT",
        "Hands", "Hands",
        "Plaza", "Plaza",
        "Ainz & Tulpe", "Ainz & Tulpe",
        "Shop In", "Shop In",
        "@cosme store", "@cosme store",
        "ドン・キホーテ", "ﾄﾞﾝ･ｷﾎｰﾃ",
        "ロフト", "ﾛﾌﾄ",
        "東急ハンズ", "ﾄｳｷｭｳﾊﾝｽﾞ",
        "PLAZA", "PLAZA",
        "アインズ＆トルペ", "ｱｲﾝｽﾞｱﾝﾄﾞﾄﾙﾍﾟ",
        "ショップイン", "ｼｮｯﾌﾟｲﾝ",
        "アットコスメストア", "ｱｯﾄｺｽﾒｽﾄｱ",
        "ハンズ", "ﾊﾝｽﾞ",
        "ドンキ", "ﾄﾞﾝｷ",
        "LOFT", "LOFT",
        "Hands", "Hands",
        "Plaza", "Plaza",
        "Ainz & Tulpe", "Ainz & Tulpe",
        "Shop In", "Shop In",
        "@cosme store", "@cosme store",
        "ドン・キホーテ", "ﾄﾞﾝ･ｷﾎｰﾃ",
        "ロフト", "ﾛﾌﾄ",
        "東急ハンズ", "ﾄｳｷｭｳﾊﾝｽﾞ",
        "PLAZA", "PLAZA",
        "アインズ＆トルペ", "ｱｲﾝｽﾞｱﾝﾄﾞﾄﾙﾍﾟ",
        "ショップイン", "ｼｮｯﾌﾟｲﾝ",
        "アットコスメストア", "ｱｯﾄｺｽﾒｽﾄｱ",
        "ハンズ", "ﾊﾝｽﾞ",
        "ドンキ", "ﾄﾞﾝｷ",
        "LOFT", "LOFT",
        "Hands", "Hands",
        "Plaza", "Plaza",
        "Ainz & Tulpe", "Ainz & Tulpe",
        "Shop In", "Shop In",
        "@cosme store", "@cosme store",
        "ツルハドラッグ", "ﾂﾙﾊﾄﾞﾗｯｸﾞ",
        "マツモトキヨシ", "ﾏﾂﾓﾄｷﾖｼ",
        "スギ薬局", "ｽｷﾞﾔｯｷｮｸ",
        "サンドラッグ", "ｻﾝﾄﾞﾗｯｸﾞ",
        "ウェルシア", "ｳｪﾙｼｱ",
        "コスモス", "ｺｽﾓｽ",
        "ディスカウントドラッグコスモス", "ﾃﾞｨｽｶｳﾝﾄﾄﾞﾗｯｸﾞｺｽﾓｽ",
        "クリエイトエス・ディー", "ｸﾘｴｲﾄｴｽ･ﾃﾞｨｰ",
        "ココカラファイン", "ｺｺｶﾗﾌｧｲﾝ",
        "富士薬品", "ﾌｼﾞﾔｸﾋﾝ",
        "クスリのアオキ", "ｸｽﾘﾉｱｵｷ",
        "V・ドラッグ", "V･ﾄﾞﾗｯｸﾞ",
        "キリン堂", "ｷﾘﾝﾄﾞｳ",
        "ドラッグユタカ", "ﾄﾞﾗｯｸﾞﾕﾀｶ",
        "ドラッグストアモリ", "ドラッグストアモリ",
        "カワチ薬品", "ｶﾜﾁﾔｸﾋﾟﾝ",
        "サツドラ", "ｻﾂﾄﾞﾗ",
        "トモズ", "ﾄﾓｽﾞ",
        "薬王堂", "ﾔｸｵｳﾄﾞｳ",
        "杏林堂", "杏林堂",
        "ゲンキー", "ｹﾞﾝｷｰ",
        "ドラッグエース", "ﾄﾞﾗｯｸﾞｴｰｽ",
        "セブン-イレブン", "ｾﾌﾞﾝ-ｲﾚﾌﾞﾝ",
        "ファミリーマート", "ﾌｧﾐﾘｰﾏｰﾄ",
        "ローソン", "ﾛｰｿﾝ",
        "ミニストップ", "ﾐﾆｽﾄｯﾌﾟ",
        "デイリーヤマザキ", "ﾃﾞｲﾘｰﾔﾏｻﾞｷ",
        "セイコーマート", "ｾｲｺｰﾏｰﾄ",
        "ポプラ", "ﾎﾟﾌﾟﾗ",
        "NewDays", "NewDays",
        "アズナス", "ｱｽﾞﾅｽ",
        "生活彩家", "ｾｲｶﾂｻｲｶ",
        "スリーエフ", "ｽﾘｰｴﾌ",
        "コミュニティ・ストア", "ｺﾐｭﾆﾃｨ･ｽﾄｱ",
        "セーブオン", "ｾｰﾌﾞｵﾝ",
        "エブリワン", "エブリワン",
        "ココストア", "ｺｺｽﾄｱ",
        "サンクス", "ｻﾝｸｽ",
        "am/pm", "am/pm",
        "サークルK", "ｻｰｸﾙK",
        "ホットスパー", "ﾎｯﾄｽﾊﾟｰ",
        "Kマート", "Kﾏｰﾄ",
        "RICマート", "RICﾏｰﾄ",
        "ヤマザキショップ", "ﾔﾏｻﾞｷｼｮｯﾌﾟ",
        "まいばすけっと", "ﾏｲﾊﾞｽｹｯﾄ",
        "ローソンストア100", "ﾛｰｿﾝｽﾄｱ100",
        "アンスリー", "ｱﾝｽﾘｰ",
        "ベルマート", "ﾍﾞﾙﾏｰﾄ",
        "ファミマ!!", "ﾌｧﾐﾏ!!",
        "ナチュラルローソン", "ﾅﾁｭﾗﾙﾛｰｿﾝ",
        "ローソン・スリーエフ", "ﾛｰｿﾝ･ｽﾘｰｴﾌ",
        "ローソンポプラ", "ﾛｰｿﾝﾎﾟﾌﾟﾗ",
        "ローソン＋スリーエフ", "ﾛｰｿﾝ＋ｽﾘｰｴﾌ",
        "ローソン＋ポプラ", "ﾛｰｿﾝ＋ﾎﾟﾌﾟﾗ",
        "ファミリーマート＋薬局", "ﾌｧﾐﾘｰﾏｰﾄ＋ﾔ\u0008ｷｮｸ",
        "ファミリーマート＋ドラッグ", "ﾌｧﾐﾘｰﾏｰﾄ＋ﾄﾞﾗｯｸﾞ",
        "セブン-イレブン＋薬局", "ｾﾌﾞﾝ-ｲﾚﾌﾞﾝ＋ﾔｯｷｮｸ",
        "セブン-イレブン＋ドラッグ", "ｾﾌﾞﾝ-ｲﾚﾌﾞﾝ＋ﾄﾞﾗｯｸﾞ",
        "ローソン＋薬局", "ﾛｰｿﾝ＋ﾔｯｷｮｸ",
        "ローソン＋ドラッグ", "ﾛｰｿﾝ＋ﾄﾞﾗｯｸﾞ",
        "ポプラ＋生活彩家", "ﾎﾟﾌﾟﾗ＋ｾｲｶﾂｻｲｶ",
        "ミニストップ＋薬局", "ﾐﾆｽﾄｯﾌﾟ＋ﾔｯｷｮｸ",
        "ミニストップ＋ドラッグ", "ﾐﾆｽﾄｯﾌﾟ＋ﾄﾞﾗｯｸﾞ",
        "スギ薬局＋調剤", "ｽｷﾞﾔｯｷｮｸ＋ﾁｮｳｻﾞｲ",
        "マツモトキヨシ＋調剤", "ﾏﾂﾓﾄｷﾖｼ＋ﾁｮｳｻﾞｲ",
        "ツルハドラッグ＋調剤", "ﾂﾙﾊﾄﾞﾗｯｸﾞ��ﾁｮｳｻﾞｲ",
        "サンドラッグ＋調剤", "ｻﾝﾄﾞﾗｯｸﾞ＋ﾁｮｳｻﾞｲ",
        "ウェルシア＋調剤", "ｳｪﾙｼｱ＋ﾁｮｳ\u0008ﾞｲ",
        "コスモス＋調剤", "ｺｽﾓｽ＋ﾁｮｳｻﾞｲ",
        "クリエイトエス・ディー＋調剤", "ｸﾘｴｲﾄｴｽ･ﾃﾞｨｰ＋ﾁｮｳｻﾞｲ",
        "ココカラファイン＋調剤", "ｺｺｶﾗﾌｧｲﾝ＋ﾁｮｳｻﾞｲ",
        "富士薬品＋調剤", "ﾌｼﾞﾔｸﾋﾝ＋ﾁｮｳｻﾞｲ",
        "クスリのアオキ＋調剤", "ｸｽﾘﾉｱｵｷ＋ﾁｮｳｻﾞｲ",
        "V・ドラッグ＋調剤", "V･ﾄﾞﾗｯｸﾞ＋ﾁｮｳｻﾞｲ",
        "キリン堂＋調剤", "ｷﾘﾝﾄﾞｳ＋ﾁｮｳｻﾞｲ",
        "ドラッグユタカ＋調剤", "ﾄﾞﾗｯｸﾞﾕﾀｶ＋ﾁｮｳｻﾞｲ",
        "ドラッグストアモリ＋調剤", "ドラッグストアモリ＋ﾁｮｳｻﾞｲ",
        "カワチ薬品", "ｶﾜﾁﾔｸﾋﾟﾝ",
        "サツドラ", "ｻﾂﾄﾞﾗ",
        "トモズ", "ﾄﾓｽﾞ",
        "薬王堂", "ﾔｸｵｳﾄﾞｳ",
        "杏林堂＋調剤", "杏林堂＋ﾁｮｳｻﾞｲ",
        "ゲンキー＋調剤", "ｹﾞﾝｷｰ＋\u0008ｮｳｻﾞｲ",
        "ドラッグエース＋調剤", "ﾄﾞﾗｯｸﾞｴｰｽ＋ﾁｮｳｻﾞｲ"
    ];

    // Function to fetch and cache individual store detail (postal code)
    const STORE_DETAIL_CACHE_KEY_PREFIX = 'store_detail_';
    const STORE_DETAIL_CACHE_EXPIRATION_TIME = 24 * 60 * 60 * 1000; // 24 hours for individual store details

    async function fetchAndCacheStoreDetail(store) {
        const individualStoreCacheKey = STORE_DETAIL_CACHE_KEY_PREFIX + store.map_store_id;
        const cachedStoreDetail = await getItemFromDB(individualStoreCacheKey);

        if (cachedStoreDetail) {
            const { timestamp, data } = cachedStoreDetail;
            const now = new Date().getTime();

            if (now - timestamp < STORE_DETAIL_CACHE_EXPIRATION_TIME) {
                logDebug(`Using cached detail for store ${store.map_store_id}`);
                Object.assign(store, data); // Merge all cached data
                return store;
            } else {
                logDebug(`Cached detail for store ${store.map_store_id} expired.`);
                await removeItemFromDB(individualStoreCacheKey); // Clear expired cache
            }
        }

        const storeDetailUrl = `/mmeu/api/v3/store/${store.map_store_id}?client_id=integrated`;
        try {
            const response = await fetch(storeDetailUrl);
            if (!response.ok) {
                throw new Error(`Failed to fetch details for store ${store.map_store_id}`);
            }
            const detailData = await response.json();
            Object.assign(store, detailData); // Merge all fetched data
            // Cache individual store detail
            const cacheData = {
                timestamp: new Date().getTime(),
                data: detailData
            };
            await setItemToDB(individualStoreCacheKey, cacheData);
            logDebug(`Detail for store ${store.map_store_id} cached.`);
            return store;
        } catch (error) {
            logDebug(`Error fetching detail for store ${store.map_store_id}: ${error}`);
            console.error(`Error fetching detail for store ${store.map_store_id}:`, error);
            return store; // Return original store even if detail fetch fails
        }
    }

    function getTextColorForBg(bgColor) {
        const color = (bgColor.charAt(0) === '#') ? bgColor.substring(1, 7) : bgColor;
        const r = parseInt(color.substring(0, 2), 16);
        const g = parseInt(color.substring(2, 4), 16);
        const b = parseInt(color.substring(4, 6), 16);
        // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
        const hsp = Math.sqrt(
            0.299 * (r * r) +
            0.587 * (g * g) +
            0.114 * (b * b)
        );
        // Using the HSP value, determine whether the color is light or dark
        return (hsp > 155) ? '#000000' : '#FFFFFF';
    }

    // Simple hash function to generate a color from a string
    function stringToColor(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        let color = '#';
        for (let i = 0; i < 3; i++) {
            let value = (hash >> (i * 8)) & 0xFF;
            color += ('00' + value.toString(16)).substr(-2);
        }
        return color;
    }

    function updateRecentlyClicked(storeName, lat, lon) {
        // Add the new store to the beginning of the array
        recentlyClickedStores.unshift({ name: storeName, lat: lat, lon: lon });
        // Keep only the two most recent
        if (recentlyClickedStores.length > 2) {
            recentlyClickedStores.pop();
        }
        // Update the display
        clickedStore1Div.textContent = recentlyClickedStores[0] ? `1. ${recentlyClickedStores[0].name}` : '';
        clickedStore2Div.textContent = recentlyClickedStores[1] ? `2. ${recentlyClickedStores[1].name}` : '';

        // Calculate and display distance if two markers are clicked
        if (recentlyClickedStores.length === 2) {
            var latlng1 = L.latLng(recentlyClickedStores[0].lat, recentlyClickedStores[0].lon);
            var latlng2 = L.latLng(recentlyClickedStores[1].lat, recentlyClickedStores[1].lon);
            var distance = latlng1.distanceTo(latlng2); // Distance in meters
            distanceBetweenMarkersDiv.textContent = `Distance: ${ (distance / 1000).toFixed(2) } km`;
        } else {
            distanceBetweenMarkersDiv.textContent = '';
        }
    }

    

    // Function to render stores on the map and list
    function renderStores(storesToRender, visitingOrder = null) {
	logDebug('Start renderStores');
        logDebug('Rendering stores with visiting order: ' + JSON.stringify(visitingOrder));
        storeList.innerHTML = ''; // Clear existing list
        markers.clearLayers(); // Clear existing markers
        if (routeLine) {
            routeLine.remove();
        }

        if (storesToRender && Array.isArray(storesToRender)) {
            // Apply exclusion filter
            storesToRender = storesToRender.filter(store => {
                const storeName = store.store_name || '';
                return !EXCLUDE_STORE_NAMES_CONTAINING.some(excludedString => storeName.includes(excludedString));
            });

            var storeCount = storesToRender.length;
            markerCountDiv.textContent = `Markers on map: ${storeCount}`;

            logDebug('Visiting order: ' + JSON.stringify(visitingOrder));
                const orderMap = new Map();
            if (visitingOrder) {
                visitingOrder.forEach((storeId, index) => {
                    orderMap.set(storeId, index + 1); // Store 1-based order
                });
                logDebug('Order map: ' + JSON.stringify(Array.from(orderMap.entries())));
            }

            storesToRender.forEach(function(store) {
                if (store.latitude && store.longitude) {
                    var markerColor = stringToColor(store.postal_code || 'default');
                    var textColor = getTextColorForBg(markerColor);

                    let markerHtml = `<div style="background-color: ${markerColor}; color: ${textColor}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; display: flex; justify-content: center; align-items: center; font-weight: bold;">`;
                    if (orderMap.has(store.map_store_id)) {
                        markerHtml += `<span>${orderMap.get(store.map_store_id)}</span>`;
                        logDebug(`Store ${store.store_name} has order ${orderMap.get(store.map_store_id)}`);
                    }
                    markerHtml += `</div>`;

                    var customIcon = L.divIcon({
                        className: 'custom-marker',
                        html: markerHtml,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12],
                        popupAnchor: [0, -12]
                    });

                    var marker = L.marker([store.latitude, store.longitude], { icon: customIcon });

                    var popupContent = document.createElement('div');
                    popupContent.appendChild(document.createTextNode(store.store_name + ' (Postal Code: '));
                    
                    var postalCodeLink = document.createElement('a');
                    postalCodeLink.href = '#';
                    postalCodeLink.textContent = store.postal_code || 'N/A';
                    postalCodeLink.style.cursor = 'pointer';
                    postalCodeLink.style.textDecoration = 'underline';
                    postalCodeLink.onclick = function(e) {
                        e.preventDefault();
                        if (store.postal_code) {
                            postalCodeFilterInput.value = store.postal_code;
                            applyFilterButton.click();
                        }
                    };
                    popupContent.appendChild(postalCodeLink);
                    popupContent.appendChild(document.createTextNode(')'));

		    var makeStartForTSP = document.createElement('button');
		    makeStartForTSP.textContent = 'Make TSP Start';
		    makeStartForTSP.style.marginLeft = '10px';
		    makeStartForTSP.onclick = (function(store) {
		        return function() {
                            const postalCode = postalCodeFilterInput.value.trim();
                            if (postalCode && postalCode === store.postal_code) {
                                const filteredStores = Array.from(allStores.values()).filter(s => s.postal_code === postalCode);
			        logDebug('Making store ' + store.store_name + ' the start for TSP');
                                const storeIndex = filteredStores.findIndex(s => s.map_store_id === store.map_store_id);
			        logDebug(`Store index in filteredStores: ${storeIndex}`);
                                if (storeIndex !== -1) {
                                    const startStoreSelector = document.getElementById('startStoreSelector');
                                    currentValue = startStoreSelector;
				    logDebug(filteredStores[storeIndex].store_name);
				   
				    logDebug(startStoreSelector.options[0].text);
				    // loop through options to find the matching store
				    for (let i = 0; i < startStoreSelector.options.length; i++) {
					if (startStoreSelector.options[i].text === filteredStores[storeIndex].store_name) {
					    startStoreSelector.selectedIndex = i;
					    logDebug(`Found matching store in selector: ${startStoreSelector.options[i].text}`);
					    break;
					}
				    }
			            // Trigger change event to update the TSP route
			            startStoreSelector.dispatchEvent(new Event('change'));
                                    //applyPostalFilter(postalCode);
                                } else {
			            logDebug(`Store ${store.store_name} not found in filteredStores.`);
			        }
                            }
			};
		    })(store);
		    popupContent.appendChild(makeStartForTSP);
		    popupContent.style.cursor = 'pointer';
		

                    marker.bindPopup(popupContent);
                    marker.addTo(markers);

                    marker.on('click', (function(store) {
                        return function() {
                            updateRecentlyClicked(store.store_name, store.latitude, store.longitude);
                            
                            const postalCode = postalCodeFilterInput.value.trim();
                            if (postalCode && postalCode === store.postal_code) {
                                const filteredStores = Array.from(allStores.values()).filter(s => s.postal_code === postalCode);
                            }
                        };
                    })(store));

                    var storeItem = document.createElement('div');
                    storeItem.className = 'store-item';

                    let displayText = '';
                    if (orderMap.has(store.map_store_id)) {
                        displayText += `${orderMap.get(store.map_store_id)}. `;
                    }
                    displayText += store.store_name;

                    var postalCodeSpan = document.createElement('span');
                    postalCodeSpan.className = 'postal-code-filter';
                    if (!orderMap.has(store.map_store_id)) {
                        postalCodeSpan.textContent = store.postal_code;
                    }
                    postalCodeSpan.style.cursor = 'pointer';
                    postalCodeSpan.style.textDecoration = 'underline';
                    postalCodeSpan.onclick = (function(code) {
                        return function(event) {
                            event.stopPropagation(); // Prevent storeItem click from firing
                            postalCodeFilterInput.value = code;
                            applyFilterButton.click();
                        };
                    })(store.postal_code);

                    storeItem.innerHTML = ''; // Clear existing text
                    if (!orderMap.has(store.map_store_id)) {
                        storeItem.appendChild(postalCodeSpan);
                    }
                    storeItem.appendChild(document.createTextNode(' ' + displayText));
                    storeItem.onclick = (function(store, m) {
                        return function() {
                            map.setView([store.latitude, store.longitude], 15);
                            m.openPopup();
                            updateRecentlyClicked(store.store_name, store.latitude, store.longitude);

                            if (!store.postal_code) {
                                fetchAndCacheStoreDetail(store)
                                    .then(updatedStore => {
                                        // Find the updated store in allStores and replace it
                                        const index = Array.from(allStores.values()).findIndex(s => s.map_store_id === updatedStore.map_store_id);
                                        if (index !== -1) {
                                            allStores.set(updatedStore.map_store_id, updatedStore);
                                            renderStores(Array.from(allStores.values())); // Re-render to update marker color and list item
                                        }
                                    })
                                    .catch(error => {
                                        console.error(`Error fetching detail for store ${store.map_store_id}:`, error);
                                    });
                            }
                        };
                    })(store, marker);
                    storeList.appendChild(storeItem);
                }
            });
            updatePostalCodeList(storesToRender, visitingOrder !== null); // Update the postal code list

            if (visitingOrder && storesToRender.length > 1) {
                const latLngs = storesToRender.map(store => [store.latitude, store.longitude]);
                routeLine = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                map.fitBounds(routeLine.getBounds());
            }
        } else {
            updatePostalCodeList([], false); // Clear the list if no stores are rendered
        }
    }

    // Function to update the list of unique postal codes or visiting order
    async function updatePostalCodeList(stores, isOrderedList = false) {
        const postalCodeList = document.getElementById('postal-code-list');
        if (!postalCodeList) return;

        postalCodeList.innerHTML = ''; // Clear existing list

        if (isOrderedList && stores.length > 0) {
            // Display the visiting order
            const postalCode = stores[0].postal_code;
            const postalInfo = await getPostalData(postalCode);
            let addressString = '';
            if (postalInfo && postalInfo.length > 0) {
                const firstEntry = postalInfo[0];
                addressString = `${firstEntry.prefecture}, ${firstEntry.city}, ${firstEntry.address} - `;
            }
            const title = document.createElement('h4');
            title.textContent = `Visiting Order for ${addressString}${postalCode}`;
            postalCodeList.appendChild(title);

            stores.forEach((store, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${store.store_name}`;
                li.style.cursor = 'pointer';
                li.onclick = () => handleTspStoreSelection(store, li);
                postalCodeList.appendChild(li);
            });

            if (stores.length > 1) {
                let totalDistance = 0;
                const distances = [];
                for (let i = 0; i < stores.length - 1; i++) {
                    const latlng1 = L.latLng(stores[i].latitude, stores[i].longitude);
                    const latlng2 = L.latLng(stores[i+1].latitude, stores[i+1].longitude);
                    const distance = latlng1.distanceTo(latlng2);
                    distances.push((distance / 1000).toFixed(2) + ' km');
                    totalDistance += distance;
                }
                const distanceDiv = document.createElement('div');
                distanceDiv.style.marginTop = '10px';
                distanceDiv.innerHTML = `<p><b>Distances:</b> ${distances.join(', ')}</p><p><b>Total Distance:</b> ${(totalDistance / 1000).toFixed(2)} km</p>`;
                postalCodeList.appendChild(distanceDiv);
            }

        } else {
            // Display unique postal codes
            const uniquePostalCodes = [...new Set(stores.map(store => store.postal_code).filter(Boolean))];
            uniquePostalCodes.sort();

            const allPostalData = await getDataFromDB(); // Fetch all data once

            for (const code of uniquePostalCodes) {
                const postalInfo = allPostalData[code] || null;
                let addressString = '';
                if (postalInfo && postalInfo.length > 0) {
                    const firstEntry = postalInfo[0];
                    addressString = `${firstEntry.prefecture}, ${firstEntry.city}, ${firstEntry.address} - `;
                }

                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = addressString + code;
                a.style.cursor = 'pointer';
                a.style.textDecoration = 'underline';
                a.onclick = function(e) {
                    e.preventDefault();
                    postalCodeFilterInput.value = code;
                    applyPostalFilter(code);
                };
                li.appendChild(a);
                postalCodeList.appendChild(li);
            }
        }
    }

    // Initial data fetch with caching
    const CACHE_KEY = 'stores_data';
    const CACHE_EXPIRATION_TIME = 60 * 60 * 1000; // 1 hour in milliseconds

    async function fetchAndCacheStores(isIncremental = false) {
        logDebug('Attempting to fetch and cache stores...');
        showLoading();
        try {
            const response = await fetch(apiUrl);
            logDebug(`API response status: ${response.status}`);
            if (!response.ok) {
                throw new Error(`Network response was not ok: ${response.statusText}`);
            }
            const data = await response.json();
            logDebug(`API data received. Store count: ${data.stores ? data.stores.length : 0}`);
            if (data.stores && Array.isArray(data.stores)) {
                let newStores = [];
                if (isIncremental) {
                    data.stores.forEach(store => {
                        if (!allStores.has(store.map_store_id)) {
                            allStores.set(store.map_store_id, store);
                            newStores.push(store);
                        }
                    });
                    logDebug(`Found ${newStores.length} new stores to add.`);
                } else {
                    allStores.clear();
                    data.stores.forEach(store => allStores.set(store.map_store_id, store));
                    newStores = data.stores;
                    logDebug('Reloading all stores.');
                }

                const storesToProcess = newStores.length > 0 ? newStores : Array.from(allStores.values());

                try {
                    await Promise.all(storesToProcess.map(store => fetchAndCacheStoreDetail(store)));
                    logDebug('All details fetched. Rendering stores...');
                    
                    // Update the main cache with all stores
                    const cacheData = {
                        timestamp: new Date().getTime(),
                        data: Array.from(allStores.values()) // Convert Map to array for JSON
                    };
                    await setItemToDB(CACHE_KEY, cacheData);
                    logDebug('Main store cache updated.');

                    if (map) {
                        try {
                            renderStores(Array.from(allStores.values()));
                        } catch (renderError) {
                            logDebug(`Error during renderStores: ${renderError}`);
                            console.error('Error during renderStores:', renderError);
                        }
                    }
                } catch (error) {
                    logDebug(`Error in Promise.all for postal codes: ${error}`);
                    console.error(`Error in Promise.all for postal codes:`, error);
                    if (map) {
                        renderStores(Array.from(allStores.values()));
                    }
                }

            } else {
                logDebug('API response did not contain a valid "stores" array.');
            }
        } catch (error) {
            logDebug(`Error fetching from API: ${error}`);
            console.error('Error:', error);
        } finally {
            hideLoading();
        }
    }

    async function forceReloadAllStores() {
        logDebug('Forcing reload of all store data...');
        allStores.clear();
        // Clear all individual store detail caches
        await clearItemsFromDBWithPrefix(STORE_DETAIL_CACHE_KEY_PREFIX);
        logDebug('All individual store detail caches cleared.');

        // Re-fetch everything
        await fetchAndCacheStores(false);
    }

    async function initializeMapWithLocation() {
        logDebug('Initializing map...');
        const mapElement = document.getElementById('map');
        if (mapElement) {
            logDebug(`Map container dimensions: ${mapElement.offsetWidth}x${mapElement.offsetHeight}`);
        } else {
            logDebug('Map container #map not found!');
            return;
        }

        map = L.map('map', {
            contextmenu: true,
            contextmenuWidth: 140,
            contextmenuItems: [{
                text: 'Center map here',
                callback: (e) => {
                    map.panTo(e.latlng);
                }
            }, {
                text: 'Zoom in',
                callback: () => {
                    map.zoomIn();
                }
            }, {
                text: 'Zoom out',
                callback: () => {
                    map.zoomOut();
                }
            }, {
                text: 'Reload Stores',
                callback: () => {
                    fetchAndCacheStores(false);
                }
            }, {
                text: 'Force Reload All Store Data',
                callback: forceReloadAllStores
            }, {
                text: 'Fetch stores from this location',
                callback: (e) => {
                    const { lat, lng } = e.latlng;
                    logDebug(`Fetching stores for new location: Lat ${lat}, Lng ${lng}`);
                    apiUrl = `http://localhost:8080/mmeu/api/v3/stores?client_id=integrated&longitude=${lng}&latitude=${lat}`;
                    fetchAndCacheStores(true); // Incremental load
                }
            }]
        }).setView([35.681236, 139.767125], 13); // Default view (Tokyo Station)

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        logDebug('Tile layer added.');

        markers = L.featureGroup().addTo(map); // Initialize markers after map is defined
        logDebug('Marker feature group added.');

        // Function to add a TopoJSON layer from a URL
        function addTopoJsonLayer(url, color) {
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    logDebug(`TopoJSON data fetched successfully from ${url}.`);
                    
                    const objectKey = Object.keys(data.objects)[0];
                    if (!objectKey) {
                        throw new Error('No objects found in TopoJSON data.');
                    }
                    logDebug(`Found TopoJSON object key: ${objectKey}`);

                    const geojsonData = topojson.feature(data, data.objects[objectKey]);
                    logDebug('Successfully converted TopoJSON to GeoJSON.');

                    const geoJsonLayer = L.geoJSON(geojsonData, {
                        style: function(feature) {
                            return {
                                color: color,
                                weight: 3,
                                opacity: 0.8
                            };
                        }
                    });
                    
                    geoJsonLayer.addTo(map);
                    logDebug('GeoJSON layer added to the map.');

                    const bounds = geoJsonLayer.getBounds();
                    if (bounds.isValid()) {
                        // Extend map bounds to include this layer
                        const mapBounds = map.getBounds();
                        if (mapBounds.isValid()) {
                            map.fitBounds(mapBounds.extend(bounds));
                        } else {
                            map.fitBounds(bounds);
                        }
                        logDebug('Map view fitted to include GeoJSON layer bounds.');
                    } else {
                        logDebug('Could not get valid bounds from GeoJSON layer.');
                    }
                })
                .catch(error => {
                    logDebug(`Error loading or processing TopoJSON/GeoJSON layer from ${url}: ${error}`);
                    console.error(`Error with TopoJSON/GeoJSON layer from ${url}:`, error);
                });
        }

        // Add the TopoJSON layers
        addTopoJsonLayer('https://geoshape.ex.nii.ac.jp/ka/topojson/2020/11/r2ka11224.topojson', 'green');
        addTopoJsonLayer('https://geoshape.ex.nii.ac.jp/ka/topojson/2020/13/r2ka13117.topojson', 'purple');
        addTopoJsonLayer('https://geoshape.ex.nii.ac.jp/ka/topojson/2020/11/r2ka11223.topojson', 'blue');

        const loadInitialStores = async () => {
            const cachedData = await getItemFromDB(CACHE_KEY);
            if (cachedData) {
                const { timestamp, data } = cachedData;
                const now = new Date().getTime();
                if (now - timestamp < CACHE_EXPIRATION_TIME) {
                    logDebug('Loading stores from cache.');
                    data.forEach(store => allStores.set(store.map_store_id, store));
                    renderStores(Array.from(allStores.values()));
                    hideLoading();
                    return; // Exit if we loaded from cache
                } else {
                    logDebug('Cached data expired.');
                    await removeItemFromDB(CACHE_KEY);
                }
            }
            await fetchAndCacheStores(false);
        };

        if (navigator.geolocation) {
            logDebug('Attempting to get current location for initial view...');
            navigator.geolocation.getCurrentPosition(async (position) => {
                var lat = position.coords.latitude;
                var lon = position.coords.longitude;
                map.setView([lat, lon], 13);
                logDebug(`Map centered on current location: Lat ${lat}, Lng ${lon}`);
                map.whenReady(loadInitialStores);
            }, async (error) => {
                logDebug(`Error getting location: ${error.message}. Falling back to default view.`);
                map.setView([35.681236, 139.767125], 13); // Default view
                map.whenReady(loadInitialStores);
            });
        } else {
            logDebug('Geolocation is not supported by this browser. Using default view.');
            map.setView([35.681236, 139.767125], 13); // Default view
            map.whenReady(loadInitialStores);
        }
    }

    let lastTspResult = null;
    let lastPostalCode = null;
    let tspSelectedStores = [];

    function handleTspStoreSelection(store, listItem) {
        const tspDistanceContainer = document.getElementById('tsp-distance-container');
        if (!tspDistanceContainer) return;

        const isSelected = listItem.classList.contains('selected');

        if (isSelected) {
            listItem.classList.remove('selected');
            tspSelectedStores = tspSelectedStores.filter(s => s.map_store_id !== store.map_store_id);
        } else {
            if (tspSelectedStores.length < 2) {
                listItem.classList.add('selected');
                tspSelectedStores.push(store);
            } else {
                alert("You can only select two stores at a time. Please deselect one first.");
                return;
            }
        }

        if (tspSelectedStores.length === 2) {
            const store1 = tspSelectedStores[0];
            const store2 = tspSelectedStores[1];
            const latlng1 = L.latLng(store1.latitude, store1.longitude);
            const latlng2 = L.latLng(store2.latitude, store2.longitude);
            const distance = latlng1.distanceTo(latlng2);
            tspDistanceContainer.innerHTML = `
                <p><b>Distance Calculation:</b></p>
                <p>1. ${store1.store_name}</p>
                <p>2. ${store2.store_name}</p>
                <p><b>Distance:</b> ${(distance / 1000).toFixed(2)} km</p>
            `;
        } else if (tspSelectedStores.length === 1) {
            const store1 = tspSelectedStores[0];
            tspDistanceContainer.innerHTML = `
                <p><b>Distance Calculation:</b></p>
                <p>1. ${store1.store_name}</p>
                <p><i>Select one more store to calculate the distance.</i></p>
            `;
        } else {
            tspDistanceContainer.innerHTML = '';
        }
    }

    function generateKML(orderedStores, postalCode) {
        let kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>TSP Route for ${postalCode}</name>
    <description>Optimal route for visiting stores in postal code ${postalCode}.</description>
    <Style id="startPlacemark">
      <IconStyle>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pins/red-dot.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Style id="lineStyle">
      <LineStyle>
        <color>7f0000ff</color>
        <width>4</width>
      </LineStyle>
    </Style>
`;
        orderedStores.forEach((store, index) => {
            kmlContent += `
    <Placemark>
      <name>${index + 1}. ${store.store_name}</name>
      <description>Postal Code: ${store.postal_code}</description>
      ${index === 0 ? '<styleUrl>#startPlacemark</styleUrl>' : ''}
      <Point>
        <coordinates>${store.longitude},${store.latitude},0</coordinates>
      </Point>
    </Placemark>
`;
        });

        kmlContent += `
    <Placemark>
      <name>Route</name>
      <styleUrl>#lineStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>
`;
        orderedStores.forEach(store => {
            kmlContent += `${store.longitude},${store.latitude},0 `;
        });
        kmlContent += `
        </coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>
`;
        return kmlContent;
    }

    document.getElementById('generateKml').addEventListener('click', function() {
        if (lastTspResult) {
            const kmlData = generateKML(lastTspResult, lastPostalCode);
            const blob = new Blob([kmlData], { type: 'application/vnd.google-earth.kml+xml' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `route_${lastPostalCode}.kml`;
            a.click();
        } else {
            alert('No TSP result available to generate KML.');
        }
    });

    async function applyPostalFilter(postalCode) {
        lastPostalCode = postalCode;
        const tspProgressDiv = document.getElementById('tsp-progress');
        if (tspProgressDiv) {
            tspProgressDiv.textContent = '';
        }
        
        tspSelectedStores = [];
        const tspDistanceContainer = document.getElementById('tsp-distance-container');
        if (tspDistanceContainer) {
            tspDistanceContainer.innerHTML = '';
        }

        const startStoreSelectorContainer = document.getElementById('start-store-selector-container');
        const startStoreSelector = document.getElementById('startStoreSelector');

        if (postalCode) {
            let filteredStores = Array.from(allStores.values()).filter(store => store.postal_code === postalCode);
            
            // Apply the same name exclusion filter as used in renderStores
            filteredStores = filteredStores.filter(store => {
                const storeName = store.store_name || '';
                return !EXCLUDE_STORE_NAMES_CONTAINING.some(excludedString => storeName.includes(excludedString));
            });

            logDebug('Filtered by postal code and name exclusions: ' + postalCode + '. Found ' + filteredStores.length + ' stores.');

            if (filteredStores.length > 1) {
                // Populate start store selector
                startStoreSelector.innerHTML = ''; // Clear previous options
                const savedSelection = await getItemFromDB('startStore-' + postalCode);
                filteredStores.forEach((store, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = store.store_name;
                    if (savedSelection !== null && index == parseInt(savedSelection, 10)) {
                        option.selected = true;
                    }
                    startStoreSelector.appendChild(option);
                });
                startStoreSelectorContainer.style.display = 'block';

                logDebug('Creating distance matrix...');
                const distanceMatrix = [];
                for (let i = 0; i < filteredStores.length; i++) {
                    distanceMatrix[i] = [];
                    for (let j = 0; j < filteredStores.length; j++) {
                        if (i === j) {
                            distanceMatrix[i][j] = 0;
                        } else {
                            const latlng1 = L.latLng(filteredStores[i].latitude, filteredStores[i].longitude);
                            const latlng2 = L.latLng(filteredStores[j].latitude, filteredStores[j].longitude);
                            distanceMatrix[i][j] = latlng1.distanceTo(latlng2);
                        }
                    }
                }

                logDebug('Attempting to create TSP worker from blob...');
                const workerCode = `
                    // Function to calculate the total distance of a tour
                    function calculateTotalDistance(tour, distanceMatrix) {
                        let distance = 0;
                        for (let i = 0; i < tour.length - 1; i++) {
                            distance += distanceMatrix[tour[i]][tour[i + 1]];
                        }
                        // Add distance from last city back to the first, if you want a closed loop
                        // distance += distanceMatrix[tour[tour.length - 1]][tour[0]];
                        return distance;
                    }

                    // 2-opt TSP solver
                    function twoOptTsp(distanceMatrix, startIndex = 0) {
                        const n = distanceMatrix.length;
                        if (n === 0) return [];

                        // Initial tour using nearest neighbor starting from startIndex
                        let tour = [];
                        let unvisited = new Set(Array.from({ length: n }, (_, i) => i));
                        let currentCity = startIndex;
                        tour.push(currentCity);
                        unvisited.delete(currentCity);

                        while (unvisited.size > 0) {
                            let nearestCity = -1;
                            let minDistance = Infinity;
                            for (const city of unvisited) {
                                if (distanceMatrix[currentCity][city] < minDistance) {
                                    minDistance = distanceMatrix[currentCity][city];
                                    nearestCity = city;
                                }
                            }
                            if (nearestCity !== -1) {
                                tour.push(nearestCity);
                                unvisited.delete(nearestCity);
                                currentCity = nearestCity;
                            } else {
                                break; // Should not happen in a connected graph
                            }
                        }

                        // 2-opt refinement
                        let improved = true;
                        let iteration = 0;
                        const maxIterations = 1000; // Safety break
                        while (improved && iteration < maxIterations) {
                            improved = false;
                            for (let i = 1; i < n - 1; i++) { // Start from 1 to keep start node fixed
                                for (let j = i + 1; j < n; j++) {
                                    const newTour = [...tour];
                                    const segment = newTour.slice(i, j + 1).reverse();
                                    for(let k = 0; k < segment.length; k++) {
                                        newTour[i + k] = segment[k];
                                    }

                                    if (calculateTotalDistance(newTour, distanceMatrix) < calculateTotalDistance(tour, distanceMatrix)) {
                                        tour = newTour;
                                        improved = true;
                                    }
                                }
                            }
                            iteration++;
                            self.postMessage({ type: 'progress', count: iteration, total: maxIterations });
                        }
                        return tour;
                    }

                    self.onmessage = function(e) {
                        try {
                            const { distanceMatrix, startIndex } = e.data;
                            if (!distanceMatrix || distanceMatrix.length === 0) {
                                self.postMessage({ type: 'result', result: [] });
                                return;
                            }
                            const result = twoOptTsp(distanceMatrix, startIndex);
                            self.postMessage({ type: 'result', result });
                        } catch (error) {
                            self.postMessage({ type: 'error', error: error.message });
                        }
                    };
                `;
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const worker = new Worker(URL.createObjectURL(blob));
                logDebug('TSP worker created from blob.');

                worker.onmessage = function(e) {
                    logDebug('Received message from TSP worker: ' + JSON.stringify(e.data));
                    if (e.data.type === 'progress') {
                        const percentage = ((e.data.count / e.data.total) * 100).toFixed(2);
                        tspProgressDiv.textContent = `TSP Progress: ${percentage}%`;
                    } else if (e.data.type === 'result') {
                        const visitingOrderIndices = e.data.result;

                        if (!visitingOrderIndices || visitingOrderIndices.length === 0) {
                            logDebug('TSP solver returned empty or invalid result. Rendering without ordering.');
                            renderStores(filteredStores);
                            return;
                        }

                        const orderedStores = visitingOrderIndices.map(index => filteredStores[index]);
                        
                        // Filter the ordered stores by name before storing them
                        const finalOrderedStores = orderedStores.filter(store => {
                            const storeName = store.store_name || '';
                            return !EXCLUDE_STORE_NAMES_CONTAINING.some(excludedString => storeName.includes(excludedString));
                        });

                        lastTspResult = finalOrderedStores;
                        document.getElementById('generateKml').disabled = false;
                        const visitingOrder = finalOrderedStores.map(store => store.map_store_id);
                        
                        renderStores(finalOrderedStores, visitingOrder);
                        tspProgressDiv.textContent = '';
                        worker.terminate();
                        logDebug('TSP worker terminated.');
                    } else if (e.data.type === 'error') {
                        logDebug('TSP worker error: ' + e.data.error);
                        renderStores(filteredStores);
                        tspProgressDiv.textContent = 'TSP Error';
                        worker.terminate();
                        logDebug('TSP worker terminated on error.');
                    }
                };

                worker.onerror = function(error) {
                    logDebug('An error occurred in the TSP worker: ' + error.message);
                    tspProgressDiv.textContent = 'TSP Worker Error';
                };

                const startIndex = parseInt(startStoreSelector.value, 10) || 0;
                logDebug(`Sending distance matrix to TSP worker with start index: ${startIndex}`);
                worker.postMessage({ distanceMatrix, startIndex });
                logDebug('Distance matrix sent.');

            } else {
                startStoreSelectorContainer.style.display = 'none';
                if (filteredStores.length === 1) {
                    if (tspProgressDiv) {
                        tspProgressDiv.textContent = 'TSP not applicable for a single store.';
                    }
                }
                renderStores(filteredStores);
            }

            const postalInfo = await getPostalData(postalCode);
            if (postalInfo) {
                logDebug(`Japan Post Data for ${postalCode}: ${JSON.stringify(postalInfo)}`);
            }

        } else {
            startStoreSelectorContainer.style.display = 'none';
            renderStores(Array.from(allStores.values()));
            logDebug('Postal code filter cleared. Showing all stores.');
        }
    }

    // Event listener for filter button
    applyFilterButton.addEventListener('click', function() {
        var filterPostalCode = postalCodeFilterInput.value.trim();
        applyPostalFilter(filterPostalCode);
    });

    // Event listener for start store selector
    document.getElementById('startStoreSelector').addEventListener('change', async function() {
        var filterPostalCode = postalCodeFilterInput.value.trim();
        if (filterPostalCode) {
            await setItemToDB('startStore-' + filterPostalCode, this.value);
            applyPostalFilter(filterPostalCode);
        }
    });

    // Event listener for clear filter button
    clearFilterButton.addEventListener('click', function() {
        postalCodeFilterInput.value = ''; // Clear the input field
        applyPostalFilter(null);
    });

    // Event listener for "Use Current Location" button
    useCurrentLocationButton.addEventListener('click', function() {
        if (navigator.geolocation) {
            logDebug('Attempting to get current location...');
            showLoading();
            navigator.geolocation.getCurrentPosition(function(position) {
                var lat = position.coords.latitude;
                var lon = position.coords.longitude;
                logDebug(`Current location: Latitude ${lat}, Longitude ${lon}`);
                apiUrl = `http://localhost:8080/mmeu/api/v3/stores?client_id=integrated&longitude=${lon}&latitude=${lat}`;
                logDebug(`Updated API URL for current location: ${apiUrl}`);
                fetchAndCacheStores(true); // Incremental load
            }, function(error) {
                logDebug(`Error getting location: ${error.message}`);
                console.error('Error getting location:', error);
                alert('Could not get your current location. Please ensure location services are enabled and you have granted permission.');
                hideLoading();
            });
        } else {
            logDebug('Geolocation is not supported by this browser.');
            alert('Geolocation is not supported by your browser.');
        }
    });

    // Event listener for "Clear Postal Cache" button
    document.getElementById('clearPostalCache').addEventListener('click', async function() {
        try {
            const db = await openDB();
            const transaction = db.transaction(postalStoreName, 'readwrite');
            const store = transaction.objectStore(postalStoreName);
            await new Promise((resolve, reject) => {
                const request = store.clear();
                request.onsuccess = resolve;
                request.onerror = reject;
            });
            await removeItemFromDB('postal_data_ken_all_rome_timestamp');
            postalCodeAddressCache = null; // Invalidate the in-memory cache
            logDebug('Postal code cache cleared.');
            alert('Postal code cache has been cleared.');
        } catch (error) {
            logDebug(`Error clearing postal code cache: ${error}`);
            alert('Error clearing postal code cache.');
        }
    });

    // Initialize map and fetch stores
    var jsStatusDiv = document.getElementById('js-status');
    if (jsStatusDiv) {
        jsStatusDiv.textContent = 'JavaScript is running!';
    }
    initializeMapWithLocation();
});
</script>
</body>
</html>
