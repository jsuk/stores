<!DOCTYPE html>
<html>
<head>
    <title>TopoJSON with Different Colors</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; }
        #map { height: 100vh; }
        #debug-container {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: calc(100% - 40px);
            max-width: 800px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        #debug-toggle {
            background: #333;
            color: white;
            border: none;
            width: 100%;
            padding: 5px;
            cursor: pointer;
            text-align: left;
            border-radius: 5px 5px 0 0;
        }
        #debug-log {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
        }
        #debug-log.collapsed {
            display: none;
        }
        .log-entry {
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        .log-error {
            color: #ff8a8a;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="map"></div>
<div id="debug-container">
    <button id="debug-toggle">Toggle Debug Log</button>
    <div id="debug-log" class="collapsed"></div>
</div>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
    // --- Visual Debugger ---
    const logDiv = document.getElementById('debug-log');
    const toggleButton = document.getElementById('debug-toggle');
    
    toggleButton.addEventListener('click', () => {
        logDiv.classList.toggle('collapsed');
    });

    function log(message, isError = false) {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        if (isError) {
            entry.classList.add('log-error');
        }
        entry.textContent = message;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    try {
        log('Script started.');

        // 1. Create the map
        var map = L.map('map').setView([35.36, 139.45], 10);
        log('Map initialized.');

        // 2. Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        log('Tile layer added.');

        // 3. Styling function
        function styleFeature(feature) {
            const color = feature.properties.postalCodeColor || '#CCCCCC';
            return {
                fillColor: color,
                color: 'white',
                weight: 1,
                opacity: 1,
                fillOpacity: 0.7
            };
        }

        // Global data structure for postal codes
        var postalCodeData = new Map();

        // 4. CSV parser and data loader
        function loadAndProcessCsv() {
            const zipUrl = '/zipcode/dl/utf/zip/utf_ken_all.zip';
            log(`Fetching ZIP data from: ${zipUrl}`);
            return fetch(zipUrl)
                .then(response => {
                    if (!response.ok) throw new Error(`Failed to fetch ZIP: ${response.statusText}`);
                    return response.blob();
                })
                .then(JSZip.loadAsync)
                .then(zip => zip.file('utf_ken_all.csv').async('text'))
                .then(csvText => {
                    log('CSV content extracted. Processing records...');
                    const rows = csvText.split(/\r?\n/);
                    let recordCount = 0;
                    rows.forEach(row => {
                        if (!row) return;
                        const columns = row.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g);
                        if (columns && columns.length >= 9) {
                            const clean = (col) => col ? col.replace(/"/g, '').trim() : '';
                            const cityCode = clean(columns[0]);
                            const postalCode = clean(columns[2]);
                            const townName = clean(columns[8]);
                            const record = { postalCode, town: townName, originalRow: row };
                            if (!postalCodeData.has(cityCode)) {
                                postalCodeData.set(cityCode, []);
                            }
                            postalCodeData.get(cityCode).push(record);
                            recordCount++;
                        }
                    });
                    log(`Finished processing CSV. Loaded ${recordCount} records.`);
                });
        }

        // 5. Popup function
        function onEachFeature(feature, layer) {
            var properties = feature.properties;
            if (properties) {
                var popupContent = "<h4>Properties</h4><ul>";
                for (var key in properties) {
                    if (key !== 'postalCodeLookup' && key !== 'postalCodeColor') {
                        popupContent += `<li><strong>${key}:</strong> ${properties[key]}</li>`;
                    }
                }
                
                if (properties.postalCode) {
                    popupContent += `<li><strong>Postal Code:</strong> ${properties.postalCode}</li>`;
                }
                popupContent += "</ul>";

                // --- Debug Info ---
                if (properties.postalCodeLookup) {
                    const lookup = properties.postalCodeLookup;
                    popupContent += "<h4>Debug Info</h4><ul>";
                    popupContent += `<li><strong>Lookup City Code:</strong> ${lookup.cityCode}</li>`;
                    popupContent += `<li><strong>Original S_NAME:</strong> ${lookup.originalSName}</li>`;
                    popupContent += `<li><strong>Normalized S_NAME:</strong> ${lookup.normalizedSName}</li>`;
                    if (lookup.found) {
                        popupContent += "<li><strong>Match Found:</strong> Yes</li>";
                        popupContent += `<li><strong>Matched CSV Record:</strong> ${lookup.matchedCsvRecord}</li>`;
                    } else {
                        popupContent += "<li><strong>Match Found:</strong> No</li>";
                    }
                    popupContent += "</ul>";
                }

                layer.bindPopup(popupContent);
            }
        }

        // 6. Main data fetching and processing logic
        var url = "https://geoshape.ex.nii.ac.jp/ka/topojson/2020/11/r2ka11224.topojson";
        
        loadAndProcessCsv().then(() => {
            log('Loading TopoJSON data...');
            fetch(url)
                .then(response => response.json())
                .then(topojsonData => {
                    log('TopoJSON data loaded. Processing geometries...');
                    var key = Object.keys(topojsonData.objects)[0];
                    if (!key) throw new Error('No objects found in TopoJSON file.');
                    
                    var geojsonCollection = topojson.feature(topojsonData, topojsonData.objects[key]);

                    // --- Assign Postal Codes ---
                    geojsonCollection.features.forEach(feature => {
                        const props = feature.properties;
                        const cityCode = (props.KEY_CODE || '').substring(0, 5);
                        const townToFind = props.S_NAME || '';
                        const normalizedTownToFind = townToFind.startsWith('大字') ? townToFind.substring(2) : townToFind;
                        const cityRecords = postalCodeData.get(cityCode);
                        
                        if (cityRecords) {
                            let bestMatch = null, bestMatchLength = -1;
                            cityRecords.forEach(record => {
                                const normalizedCsvTown = record.town.replace(/（.*/, '');
                                if (normalizedTownToFind.startsWith(normalizedCsvTown) && normalizedCsvTown.length > bestMatchLength) {
                                    bestMatchLength = normalizedCsvTown.length;
                                    bestMatch = record;
                                }
                            });
                            if (!bestMatch) bestMatch = cityRecords.find(r => r.town === "以下に掲載がない場合");
                            if (bestMatch) {
                                props.postalCode = bestMatch.postalCode;
                                props.postalCodeLookup = {
                                    found: true,
                                    cityCode: cityCode,
                                    originalSName: townToFind,
                                    normalizedSName: normalizedTownToFind,
                                    matchedCsvRecord: bestMatch.originalRow
                                };
                            }
                        }
                        if (!props.postalCode) {
                            props.postalCodeLookup = { found: false, cityCode: cityCode, originalSName: townToFind };
                        }
                    });
                    log('Postal codes assigned.');

                    // --- Build Adjacency Graph ---
                    log('Building adjacency graph...');
                    const neighbors = new Map();
                    geojsonCollection.features.forEach((feature, i) => {
                        const postalCode = feature.properties.postalCode;
                        if (!postalCode) return;
                        if (!neighbors.has(postalCode)) neighbors.set(postalCode, new Set());

                        const geom = feature.geometry;
                        geojsonCollection.features.forEach((otherFeature, j) => {
                            if (i === j) return;
                            const otherPostalCode = otherFeature.properties.postalCode;
                            if (!otherPostalCode || postalCode === otherPostalCode) return;

                            // Simple bounding box intersection for adjacency check
                            const bounds1 = L.geoJSON(geom).getBounds();
                            const bounds2 = L.geoJSON(otherFeature.geometry).getBounds();
                            if (bounds1.intersects(bounds2)) {
                                neighbors.get(postalCode).add(otherPostalCode);
                            }
                        });
                    });
                    log('Adjacency graph built.');

                    // --- Color Assignment ---
                    log('Assigning colors...');
                    const postalCodeColors = new Map();
                    const colorPalette = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf'];
                    const postalCodes = Array.from(neighbors.keys());

                    postalCodes.forEach(postalCode => {
                        const neighborColors = new Set(Array.from(neighbors.get(postalCode)).map(p => postalCodeColors.get(p)));
                        const availableColor = colorPalette.find(c => !neighborColors.has(c));
                        postalCodeColors.set(postalCode, availableColor || '#CCCCCC');
                    });

                    geojsonCollection.features.forEach(feature => {
                        feature.properties.postalCodeColor = postalCodeColors.get(feature.properties.postalCode);
                    });
                    log('Colors assigned.');

                    // --- Render Map ---
                    var geojsonLayer = L.geoJSON(geojsonCollection, {
                        style: styleFeature,
                        onEachFeature: onEachFeature
                    }).addTo(map);

                    map.fitBounds(geojsonLayer.getBounds());
                    log('Map layer added successfully.');
                })
                .catch(error => log(`Error processing TopoJSON: ${error.message}`, true));
        }).catch(error => log(`Error processing CSV/ZIP: ${error.message}`, true));

    } catch (e) {
        log(`A critical error occurred: ${e.message}`, true);
    }
</script>

</body>
</html>